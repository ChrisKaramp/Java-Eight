# Εργασία Προγραμματισμός ΙΙ


## Στοιχεία Μαθήματος
- Τμήμα: Διοικητικής Επιστήμης και Τεχνολογίας (ΔΕΤ)
- Μάθημα: Προγραμματισμός ΙΙ
- Διδάσκων: Διομήδης Σπινέλλης
- Ακαδημαϊκό Έτος: 2025–2026


## Στοιχεία Ομάδας:

```
ΟΜΑΔΑ #13
ΟΝΟΜΑ ΟΜΑΔΑΣ: JAVA EIGHT
ΜΕΛΗ: 8
1.
- Ονοματεπώνυμο: ΔΗΜΟΥ ΠΑΝΑΓΙΩΤΗΣ (αρχηγός ομάδας)
- Αριθμός Μητρώου: 8220219
2.
- Ονοματεπώνυμο: ΚΑΡΑΜΠΕΛΑΣ ΧΡΗΣΤΟΣ
- Αριθμός Μητρώου: 8210051
3.
- Ονοματεπώνυμο: ΜΕΤΤΟΥΡΗ ΔΗΜΗΤΡΙΑΝΑ
- Αριθμός Μητρώου: 8220212
4.
- Ονοματεπώνυμο: ΑΔΑΜΑΚΗ ΔΑΝΑΗ-ΑΙΚΑΤΕΡΙΝΗ
- Αριθμός Μητρώου: 8240004
5.
- Ονοματεπώνυμο: ΔΗΜΟΥ ΑΛΕΞΑΝΔΡΑ-ΧΡΙΣΤΙΝΑ
- Αριθμός Μητρώου: 8240042
6.
- Ονοματεπώνυμο: ΝΤΑΓΚΑ ΚΛΕΙΩ-ΑΙΚΑΤΕΡΙΝΗ
- Αριθμός Μητρώου: 8240096
7.
- Ονοματεπώνυμο: ΝΤΡΟΥΛΙΑ ΘΕΜΙΔΑ-ΜΑΡΙΑ
- Αριθμός Μητρώου: 8240098
8.
- Ονοματεπώνυμο: ΓΟΓΓΑΚΗΣ ΙΩΑΝΝΗΣ
- Αριθμός Μητρώου: 8240317
```

## Περιγραφή Εργασίας

```
Η εφαρμογή βοηθάει το χρήστη να υπολογίζει γρήγορα σύνολα και υποσύνολα που σχετίζονται με προϋπολογισμό μίας χώρας, με βάση ένα συγκεκριμένο σχήμα που εκδόθηκε μάλιστα και στο Ε.Τ..
(ΦΕΚ 249/τ.Α'/20-12-2021, NOMOΣ ΥΠ’ ΑΡΙΘΜ. 4874)
Είναι λειτουργική, γρήγορη, προσφέρει ταξινομημένη αποθήκευση δεδομένων σε csv αρχεία και μπορείς να εισαγάγεις και νέα έτη, με διαφορετικά ποσά. Προσφέρει εύκολο καθαρισμό πεδίων και δυνητική σύγκριση με αντίστοιχα αρχεία ξένων χωρών, αρκεί να έχουν την ίδια δομή.
```


## Σύντομη λειτουργική αναφορά

### Η εφαρμογή:

```
o	Δημιουργεί φάκελο δεδομένων, εφόσον αυτός δεν υπάρχει.
o	Αντιγράφει τα αρχεία δεδομένων από το jar στο φάκελο δεδομένων.
o	Εναλλακτικά, δημιουργεί αρχείο δεδομένων εφόσον ο φάκελος είναι άδειος για οποιοδήποτε λόγο (δεν έχει αρχεία το jar, δημιουργήθηκε ο φάκελος αλλά απέτυχε η αντιγραφή, η εκτέλεση έγινε μέσω VSC)
o	Ελέγχει τη φόρτωση δεδομένων από εξωτερικό αρχείο.
o	Τοποθετεί τα δεδομένα στη διεπαφή χρήστη.
o	Υπολογίζει τα συνολικά ποσά και τα τοποθετεί αυτόματα σε labels με κάθε είσοδο δεδομένων στους spinners.
o	Ελέγχει την εγκυρότητα των ποσών (μόνο ακέραιοι).
o	Δίνει στο χρήστη τη δυνατότητα επιλογής ετών.
o	Χρησιμοποιεί ένα παράθυρο για την προέλευση και ένα για τη διανομή του προϋπολογισμού.
o	Συλλέγει τα δεδομένα από τη διεπαφή και τα αποθηκεύει στο αρχείο δεδομένων, ενημερώνοντάς τα.
```


## Τεχνολογίες
- Γλώσσα προγραμματισμού: Java, version 25
- Build & dependency management: Maven 3.9.11
- IDE: Visual Studio Code
- UML / Diagrams: Mermaid
- Documentation: Markdown, JavaDoc
- Λειτουργικό σύστημα: Windows 11 (PowerShell)
- Version control: Git, GitHub
- File viewer: CSVLint
- Package installer: Winget, Chocolatey
- Video composition: Blender
- Presentations projection: Microsoft Office 365 Powerpoint


## Απαιτήσεις / Περιβάλλον
- Java: 25 (Oracle)
- Maven: 3.9.11
- Maven home: C:\ProgramData\chocolatey\lib\maven\apache-maven-3.9.11
- Λειτουργικό σύστημα: Windows 11 (64-bit)
- Κέλυφος: PowerShell 7.5.4.
- Default locale: en_US
- Platform encoding: UTF-8


## Οδηγίες Μεταγλώττισης και Εκτέλεσης (PowerShell)

Από τον ριζικό φάκελο του project:

```powershell
mvn clean
mvn package
java -jar target\pfad_j8-1.0.jar
```

## Οδηγίες Χρήσης

Ο χρήστης:
- Εισάγει/μεταβάλλει τα ποσά στη διεπαφή, είτε πληκτρολογώντας και ENTER, είτε με τα βελάκια των spinners για αυξομείωση κατά 1.
- Αποθηκεύει τα δεδομένα, μαζικά χρησιμοποιώντας buttons.
- Επιλέγει έτος μέσω drop down combobox menu.
- Επαναφέρει με συντομεύσεις τα ποσά στο 0.


## Δομή Αποθετηρίου

```text
repo-root/
├── pom.xml # Ρυθμίσεις Maven
├── src/
│ ├── main/
│ │ ├── java/ # Πηγαίος κώδικας εφαρμογής - κλάσεις
│ │ └── resources/data # Αρχεία δεδομένων .csv
│ └── test/
│ └── java/ # Μονάδες ελέγχου (tests)
├── README.md # Τεχνική αναφορά
└── docs/ # Τεκμηρίωση & UML
```

## Τεκμηρίωση JavaDoc (fork)

📘 [JavaDoc](https://Duke13gr.github.io/Java-Eight/apidocs/)




## Διάγραμμα UML

## Σχεδιασμός Συστήματος (UML)

Το διάγραμμα UML της εφαρμογής βρίσκεται στο αρχείο:

- `docs/uml.png`

👉 [Διάγραμμα UML](docs/uml.png)


Το διάγραμμα περιγράφει:
- τις βασικές κλάσεις της εφαρμογής
- τις σχέσεις κληρονομικότητας και συσχέτισης
- τις κύριες μεθόδους και τα δεδομένα που διαχειρίζονται

```mermaid 
graph TD
    %% Models and Core Logic
    subgraph Logic_Layer [Logic & Models]
        BOWM[Budget_origin_window_model]
        BDWM[Budget_distribution_window_model]
        CONST[Constants.java]
        PFAD[Pfad.java]
    end

    %% UI Components
    subgraph UI_Layer [User Interface]
        PUA[Panel_using_array]
        LB[Listening_button]
        LS[Listening_spinner]
        LC[Listening_combobox]
    end

    %% Data Storage
    subgraph Storage [Data & Resources]
        GREECE[(Greece.csv)]
        ORG[(organic_data.csv)]
    end

    %% Relationships
    BOWM -->|Δημιουργεί ArrayList| PUA
    BDWM -->|Δημιουργεί ArrayList| PUA
    
    PUA -->|Τοποθετεί| LB
    PUA -->|Τοποθετεί| LS
    
    LB -.->|Έλεγχος μέσω Getter/Setter| PUA
    LS -.->|Έλεγχος μέσω Getter/Setter| PUA
    
    LC -->|Έλεγχος διαδικασιών| YEARS[Έτη / Year Processes]
    
    PFAD -->|Ορίζει διαδρομές| GREECE
    PFAD -->|Ορίζει διαδρομές| ORG
    CONST -->|Παράμετροι| BOWM
    ```

## Επισκόπηση δομών δεδομένων

### Α. ΔΙΕΠΑΦΗ

Η εφαρμογή διαχειρίζεται αριθμητικά δεδομένα που εισάγονται από τον χρήστη μέσω γραφικών στοιχείων (spinners) και χρησιμοποιούνται για την εκτέλεση υπολογισμών και πράξεων συνόλων. Τα δεδομένα αυτά αναπαρίστανται εσωτερικά ως ακέραιες τιμές τύπου int, σύμφωνα με τα όρια που ορίζονται από τον τύπο Integer.
Για την οργάνωση των δεδομένων της διεπαφής, χρησιμοποιούνται πίνακες γραφικών στοιχείων, όπως πίνακες από JLabel, JButton και JSpinner, οι οποίοι επιτρέπουν την ομοιόμορφη διαχείριση και την επαναχρησιμοποίηση κοινής λειτουργικότητας σε πολλαπλά panels. Η επιλογή της χρήσης πινάκων διευκολύνει την υλοποίηση επαναληπτικών διαδικασιών για την αρχικοποίηση, την ενημέρωση και τον έλεγχο των στοιχείων της διεπαφής.
Η ανταλλαγή δεδομένων μεταξύ των επιμέρους κλάσεων και panels πραγματοποιείται μέσω παραμέτρων και αναφορών σε κοινά αντικείμενα, επιτρέποντας την πρόσβαση των γραφικών στοιχείων στα δεδομένα εισόδου και στα αποτελέσματα των υπολογισμών. Η προσέγγιση αυτή αυξάνει την ευελιξία της εφαρμογής, με τίμημα την αυξημένη πολυπλοκότητα ορισμένων κλάσεων. Χρησιμοποιούνται επίσης πίνακες αντικειμένων, για να αποθηκευτούν τα ενεργά panel και να παρέχονται όλα ως παράμετροι σε όλα, ακόμα δε και τα widgets μπορούν να διαθέτουν αυτές τις πληροφορίες, μέσω κληρονομικότητας.

### Β. ΑΡΧΕΙΑ

Τα δεδομένα της εφαρμογής αποθηκεύονται σε αρχεία μορφής .csv, στα οποία όλα τα πεδία αποθηκεύονται ως συμβολοσειρές χαρακτήρων (String). Η πρώτη γραμμή κάθε αρχείου περιλαμβάνει τις επικεφαλίδες (headers), οι οποίες περιγράφουν τα οικονομικά μεγέθη και τις διοικητικές κατηγορίες του κρατικού προϋπολογισμού, ενώ οι επόμενες γραμμές περιέχουν τις αντίστοιχες τιμές για κάθε έτος. 
Η μορφοποίηση των εγγραφών, γίνεται με δομές δεδομένων όπως συλλογές (Collection / Set) για εισαγωγή διαχωριστή, και ArrayList. Ο διαχωριστής είναι ο «,» και αποθηκεύεται στο αρχείο/κλάση σταθερών. Τα δεδομένα γράφονται επίσης και σε έναν διδιάστατο πίνακα ακεραίων όταν διαβάζονται από το αρχείο στην εφαρμογή για χρήση από κλάσεις που χρειάζονται τα δεδομένα στη συγκεκριμένη μορφή, δομή και τύπο.
Η δομή των δεδομένων είναι επίπεδη (tabular), με την πρώτη στήλη να αντιστοιχεί στο έτος αναφοράς και τις επόμενες στήλες να περιλαμβάνουν συνολικά έσοδα, επιμέρους κατηγορίες εσόδων, συνολικά έξοδα, κατηγορίες εξόδων, καθώς και αναλυτική κατανομή ανά φορέα και υπουργείο. Κατά την εκτέλεση της εφαρμογής, οι τιμές ανακτώνται από το αρχείο CSV, αναλύονται και, όπου απαιτείται, μετατρέπονται σε αριθμητικές τιμές για την εκτέλεση υπολογισμών και πράξεων συνόλων.
Η αποθήκευση των δεδομένων σε μορφή CSV επιλέχθηκε λόγω της απλότητας, της αναγνωσιμότητας και της δυνατότητας εύκολης επεξεργασίας των αρχείων από εξωτερικές εφαρμογές, καθώς και της ανεξαρτησίας από συγκεκριμένο σύστημα βάσης δεδομένων.

### Γ. ΤΟ ΑΡΧΕΙΟ/ΚΛΑΣΗ “Constants.csv”

Περιέχει τις σταθερές που χρησιμοποιούνται από την εφαρμογή. Μεταξύ άλλων, ορίζεται ένας πίνακας που περιέχει τις headers που θα γραφτούν στα αρχεία όταν αυτά δημιουργηθούν και αρχικοποιηθούν, 126 το σύνολο. Επίσης ορίζονται τα όρια των panels για να γνωστοποιείται στις κλάσεις που κτίζουν διεπαφές απλώνοντας τα widgets στα panel πότε να ξεκινάνε και πότε να σταματάνε τη σχεδίαση, αλλά και πόσες στήλες και γραμμές θα έχει αυτή η σχεδίαση. Η κλάση “Panel_using_array.java” το κάνει αυτό, μέσω ενός αλγορίθμου που πάντα στρώνει 1 + Ν widgets στο πάνελ ανά γραμμή. Για κάθε γραμμή, ένα κουμπί + Ν spinners ή μία title label και Ν subtotal labels.


## Επισκόπηση κλάσεων και αλγορίθμων που χρησιμοποιούν


### Περιγραφή και καθήκοντα κάθε κλάσης

Οι κλάσεις επιγραμματικά:
1.	Pfad.java
2.	Copy_from_jar_to_data_folder.java
3.	Build_data_file.java
4.	Add_record_to_file.java
5.	Get_data_from_file.java
6.	Budget_origin_window_model.java
7.	Budget_distribution_window_model.java
8.	Top_panel_bo_model.java
9.	Bottom_panel_bo_model.java
10.	Top_panel_bd_model.java
11.	Bottom_panel_bd_model.java
12.	Panel_using_array.java
13.	Listening_button.java
14.	Button_handler.java
15.	Listening_spinner.java
16.	Add_year.java
17.	Get_years.java
18.	Sort_and_save_data.java
19.	File_data_getter
20.	Listening_combobox.java
21.	Widget_filler.java
22.	Widget_getter.java
23.	Mass_update.java
24.	Constants.java


### Περιγραφή και καθήκοντα κλάσεων:

1.	Pfad.java -> η βασική κλάση που έχει την main.
•	Καλεί την διαδικαστική κλάση Copy_from_jar_to_data_folder.java η οποία ελέγχει την ύπαρξη και αναλόγως δημιουργεί το φάκελο δεδομένων (το όνομα αυτού ορίζεται στην Constants.java). Κατόπιν η κλάση αυτή εξαγάγει τα αρχεία δεδομένων από το .jar και τα αντιγράφει στο φάκελο δεδομένων για να μπορεί ο χρήστης να γράψει σε αυτά.
•	Ελέγχει αν υπάρχει το αρχείο δεδομένων και αν όχι, καλεί τη σχετική κλάση για να δημιουργηθεί σωστά (Build_data_file.java). Αν δε μπορέσει να δημιουργήσει το αρχείο, σταματάει την εκτέλεση, και κάνει έξοδο επιστρέφοντας κωδικό λάθους και μήνυμα.
•	προχωράει καλώντας την κλάση Budget_origin_window_model.java, που δημιουργεί το πρώτο παράθυρο της γραφικής διεπαφής, την προέλευση του προϋπολογισμού.

2.	Copy_from_jar_to_data_folder.java -> η κλάση δημιουργίας φακέλων και χειρισμού jar.
Η λειτουργία της αναφέρεται στο 1., και επιπρόσθετα να αναφερθεί ότι ένα η εφαρμογή δεν τρέξει από jar αλλά από VSC ΔΕΝ κάνει αντιγραφή από jar, απλώς εμφανίζει σχετικό μήνυμα και επιστρέφει τον έλεγχο στην 1. Έχει τις απαραίτητες εξαιρέσεις και μηνύματα προς το χρήστη.

3.	Build_data_file.java -> η κλάση δημιουργίας αρχείου δεδομένων εφόσον δεν υπάρχει jar.
Εφόσον δεν υπάρχει αρχείο δεδομένων, για οποιονδήποτε λόγο, συνήθως εκτέλεση από VSC, αυτή η κλάση το δημιουργεί και εισαγάγει την πρώτη εγγραφή με μηδέν ποσά για το φετινό έτος χρησιμοποιώντας την επόμενη κλάση Add_record_to_file.java και φυσικά περιλαμβάνει τις απαραίτητες εξαιρέσεις και μηνύματα προς το χρήστη.

4.	Add_record_to_file.java -> κλάση εισαγωγής εγγραφής σε αρχείο csv.
Προφανώς εισάγει μία εγγραφή στο αρχείο δεδομένων, (ορίζεται στο Constants.java) στο τέλος του με ασφαλή τρόπο και χειρισμό εξαιρέσεων

5.	Get_data_from_file.java -> κλάση για φόρτωση δεδομένων από αρχείο σε δομές δεδομένων.
εφόσον υπάρχει το αρχείο δεδομένων, παίρνει τις εγγραφές του, και τις βάζει σε ΔΥΟ ΔΟΜΕΣ ΔΕΔΟΜΕΝΩΝ: 
•	μία λίστα εγγραφών για το αρχείο [2025, 0, 0, 0, …,0], η οποία αργότερα ταξινομείται ως collection και
•	έναν πίνακα δύο διαστάσεων String και αυτός βγαίνει από την προηγούμενη λίστα ταξινομημένος για να μπούν τα δεδομένα του στα Spinner μέσω της Widget_Filler.java.

6.	Budget_origin_window_model.java  -> η κλάση που δημιουργεί το παράθυρο προέλευσης προϋπολογισμού.
Πρόκειται για το αρχικό παράθυρο που εμφανίζεται, περιέχει GUI και διαιρείται σε:
•	TOP PANEL (Top_panel_bο_model.java):  εκεί βάζεις ένα ένα ένα χειροκίνητα τα components πχ επιλογής έτους, χώρας, εκκίνησης δεύτερου παραθύρου (κατανομής προϋπολογισμού), Budget_distribution_window_model.java.
•	LEFT PANEL που μπαίνουν τα components των εσόδων. Αυτό δημιουργείται από τρεις πίνακες με labels, buttons και spinners αντίστοιχα, μέσω της κλάσης Panel_using_array.java, θα την δούμε πιο κάτω.
•	RIGHT PANEL για τα έξοδα, ισχύουν τα ίδια με το LEFT PANEL.
•	BOTTOM PANEL Bottom_panel_bο_model.java για τα αποτελέσματα, ισχύουν τα ίδια με το LEFT/RIGHT PANEL, αφού πρόκειται για labels που εμφανίζουν σύνολα και υποσύνολα.

7.	Budget_distribution_window_model.java -> η κλάση που δημιουργεί το παράθυρο κατανομής προϋπολογισμού.
Πρόκειται για το δεύτερο παράθυρο, το οποίο είναι διαιρεμένο σε:
•	TOP PANEL Top_panel_bd_model.java που έχει απλώς τις τρεις labels, δε λαμβάνουν δεδομένα, μπήκαν με το χέρι.
•	MIDDLE PANEL που περιέχει τα PANEL1,2,3 ΕΝΣΩΜΑΤΩΜΕΝΑ και δημιουργούνται όλα με την Panel_using_array.java που τα γεμίζει με spinners τιμών και υποσυνόλων. Και εν τέλει, labels για τα γενικά υποσύνολα, όπως φαίνεται κατά την εκτέλεση.
•	BOTTOM PANEL Bottom_panel_bd_model.java για τα σύνολα ως labels. Δημιουργείται και αυτό με την Panel_using_array.java με αυτόματο τρόπο.
Επιπλέον χρησιμοποιεί την κλάση Widget_filler.java για να γεμίσει τα spinners του επιλεγμένου έτους με τιμές.

8.	Top_panel_bο_model.java εξηγήθηκε παραπάνω στο 6.
Προφανώς bo=budget origin, bd=budget distribution.

9.	Bottom_panel_bο_model.java βλ. 6.

10.	Top_panel_bd_model.java βλ. 7.

11.	Bottom_panel_bd_model.java βλ. 7.

12.	Panel_using_array.java -> η κλάση που αυτοματοποιεί την τοποθέτηση 1+Ν components σε ένα panel.
Κτίζει τρείς πίνακες στους οποίους βάζει labels, buttons, spinners διαβάζοντας με τον κατάλληλο αλγόριθμο από το Constants τον πίνακα με τα headers. Ο αλγόριθμός είναι κτισμένος ώστε να τοποθετεί αργότερα σε ένα πάνελ 1 κουμπί και δίπλα ανάλογα spinners (ή μία label και δίπλα ανάλογες labels που δέχονται/υπολογίζουν σύνολα). 
Περνάς ως παράμετρο τις στήλες που θες. Στο πρώτο παράθυρο έχουμε 2 στήλες. Άρα θα τοποθετήσει 1+1 (κουμπί+spinner). Στο δεύτερο έχουμε 4 στήλες, άρα 1+3. Λειτουργεί για οποιοδήποτε αριθμό στηλών, απλώς εδώ χρειαζόμαστε μόνο 2 και 4 στήλες.
Επίσης ως παράμετρο περνάς και αν θες ή όχι η πρώτη γραμμή να είναι labels, για τα σύνολα. Ο τρόπος προσπέλασης στα components που τοποθετούνται, είναι το πέρασμα παραμέτρων όπως αναφέρθηκε ως πρόβλημα που αντιμετωπίστηκε και λύθηκε στο σχετικό κεφάλαιο.

13.	Listening_button.java -> κλάση ειδικού button.
Δημιουργεί ένα νέο είδος button, μέσω extends JButton, που συνοδεύεται από την Button_handler.java που ακούει το πάτημα του και κάνει μία συγκεκριμένη ενέργεια.

14.	Button_handler.java -> ο event listener του ειδικού κουμπιού παραπάνω.
Με την switch που έχει επιλέγει τι θα κάνει κάθε φορά, με βάση μια συμβολοσειρά που δίνεται ως παράμετρος για δηλώσει λειτουργία. Έχουν προστεθεί λειτουργίες κουμπιών όπως αυτό που ανοίγει το δεύτερο παράθυρο, μαζική αποθήκευση (δείτε κώδικα για πιο πολλές πληροφορίες)

15.	Listening_Spinner.java -> κλάση ειδικού JSpinner.
Πρόκειται για calculators που βάζουν τα σύνολα με κάθε αλλαγή στο περιεχόμενο. Επίσης είναι κλειδωμένα σε Integer να μη μπορούν να γράψουν παρά μόνο αριθμητικά ψηφία επάνω. Αν κάποιος βάλει κείμενο με το ENTER επιστρέφει στην προηγούμενη ακέραια τιμή κι έτσι δε χρειάζεται ούτε ειδοποίηση για το χρήστη.
Σε κάθε αλλαγή ποσών, είτε με ENTER, είτε με τα βελάκια, ενημερώνονται και τα (υπο)σύνολα, αλλά φυσικά ο χρήστης πρέπει να πατήσει το κουμπί της αποθήκευσης για να καταχωρηθούν.

16.	Add_year.java -> κλάση προσθήκης έτους.
Προσθέτει ένα νέο έτος με μηδενικά ποσά, στο αρχείο, και το μενού και το διατηρεί ταξινομημένο.
Παίρνει από την Get_years.java τα έτη από το αρχείο δεδομένων για να ελέγξει αν ήδη υπάρχει το έτος στο αρχείο και το μενού. 
Χρησιμοποιεί την κλάση Add_record_to_file.java για να γράψει την έγγραφή του νέου έτους στο αρχείο δεδομένων και μετά την Sort_and_save_data.java ώστε να διατηρείται και αυτό ταξινομημένο.
Διαχειρίζεται εξαιρέσεις.

17.	Get_years.java -> κλάση που βρίσκει τα ήδη υπάρχοντα έτη.
Χρησιμοποιεί τη μέθοδο Get_years_into_strings_array που επιστρέφει έναν πίνακα συμβολοσειρών με τα έτη που υπάρχουν στο αρχείο δεδομένων.
Διαχειρίζεται εξαιρέσεις.

18.	Sort_and_save_data.java -> κλάση που ταξινομεί και αποθηκεύει όλες τις εγγραφές του αρχείου δεδομένων.
Παίρνει όλες τις εγγραφές του αρχείου δεδομένων ταξινομημένες χρησιμοποιώντας την κλάση File_data_getter.java μέθοδο αυτής getDataFileRecords μέσω στιγμιοτύπου. Τις αποθηκεύει σε κατάλληλη δομή δεδομένων.
Χρησιμοποιεί την μέθοδο write_record της κλάσης Add_record_to_file.java για να γράψει μία-μία τις εγγραφές ξανά, ταξινομημένες. Έχει μια flag που τη χρησιμοποιεί για να γράψει την πρώτη εγγραφή (headers) σβήνοντας ό,τι υπάρχει στο αρχείο (overwrite) και αμέσως μετά η flag γίνεται αληθής για να γίνουν οι υπόλοιπες εγγραφές append στο τέλος του αρχείου χωρίς να το σβήνει.
Διαχειρίζεται εξαιρέσεις.

19.	File_data_getter.java -> κλάση λήψης δεδομένων από αρχείο.
Δημιουργεί στιγμιότυπα των οποίων αν καλέσεις τη μέθοδο που θες λαμβάνεις τα δεδομένα στην δομή που θες (πίνακα ή λίστα συμβολοσειρών δύο διαστάσεων).
Για κάθε χρήση από άλλες κλάσεις.
Διαχειρίζεται εξαιρέσεις.

20.	Listening_combobox.java -> κλάση υλοποίησης του μενού επιλογής έτους.
Χρησιμοποιεί την κλάση Widget_filler.java για να γεμίσει τα spinners του επιλεγμένου έτους με τιμές. Αφορά το παράθυρο προέλευσης προϋπολογισμού.
Για το δεύτερο παράθυρο, κατανομής προϋπολογισμού η διαδικασία είναι διαφορετική, βλ. 7.
Διαχειρίζεται εξαιρέσεις.

21.	Widget_filler.java -> κλάση που γεμίζει spinners ενός panel με τιμές.
Χρησιμοποιεί την File_data_getter.java για να λάβει πίνακα ακεραίων δύο διαστάσεων με τις τιμές που βρίσκονται στο αρχείο. Μοιράζει τις τιμές με αλγόριθμο στα spinners.
Διαχειρίζεται εξαιρέσεις.

22.	Widget_getter.java -> κλάση που παίρνει τις τιμές των widgets και τις αποθηκεύει στο αρχείο δεδομένων.
Σαρώνει τα components ενός panel ανά κατηγορία και με αλγόριθμό τοποθετεί τις τιμές στις κατάλληλες θέσεις ενός μονοδιάστατου πίνακα ακεραίων, ο οποίος θα αποτελέσει τμήμα εγγραφής στην κλάση Mass_update.java που αναφέρεται παρακάτω.

23.	Mass_update.java -> κλάση που υλοποιεί τη μαζική αποθήκευση.
Λαμβάνει και αποθηκεύει όλες τις εγγραφές του αρχείου δεδομένων σε κατάλληλη δομή δεδομένων.
Απομονώνει την εγγραφή που αφορά το επιλεγμένο έτος.
Λαμβάνει από κλάση Widget_getter.java μέσω στιγμιοτύπου τον μονοδιάστατο πίνακα που έκτισε με τις τρέχουσες τιμές των components.
Ενημερώνει την εγγραφή που απομονώθηκε.
Γράφει ξανά τα δεδομένα πίσω στο αρχείο.
Διαχειρίζεται εξαιρέσεις.
Τυπώνει κατάλληλα μηνύματα, τόσο στο τερματικό, όσο και παραθυρικά.

24.	Constants.java -> κλάση σταθερών
Περιέχει τις σταθερές που χρησιμοποιεί η εφαρμογή, προστέθηκαν ΟΛΑ τα πεδία και των δύο οθονών σε μία σταθερά πίνακα και από εκεί κτίζει αρχείο και components για την GUI, έχει και σημάδια για να ξέρει πότε να αλλάζει συμπεριφορά. Είναι το βασικότερο αρχείο της εφαρμογής.


### Ειδικά θέματα αλγορίθμων της εφαρμογής

#### Α. Η εξαγωγή των αρχείων δεδομένων από το jar αρχείο της εφαρμογής

Την εργασία αυτή διεκπεραιώνει η κλάση “ Copy_from_jar_to_data_folder.java” η οποία είναι διαδικαστική, δε δημιουργείται κάποιο στιγμιότυπο αυτής, απλώς ασχολείται με διαδικασίες που αφορούν φάκελους και αρχεία δεδομένων.

Το πρόβλημα δεν ήταν στη δημιουργία του φάκελου δεδομένων, αλλά στην εξαγωγή των .csv αρχείων δεδομένων από το αρχείο .jar και την αντιγραφή αυτών στο φάκελο δεδομένων. Αυτή η διαδικασία είναι απαραίτητη εφόσον επιθυμείς να γράψεις και όχι μόνο να διαβάσεις αρχεία δεδομένων. Τα αρχεία που βρίσκονται στο .jar είναι μόνο για ανάγνωση και πρέπει να εξαχθούν και να τοποθετηθούν σε ξεχωριστό φάκελο εκτός .jar για να επιτευχθεί η εγγραφή σε αυτά. Και μάλιστα θα πρέπει να έχουν και δικαιώματα εγγραφής, κάτι που δεν ήταν θέμα σε Powershell, αλλά σε UNIX θα έπρεπε να εφαρμοστεί και κάποια chmod εντολή.

Ήταν κάτι καινούργιο για εμάς και χρησιμοποιήσαμε ΠΤΝ. Η ερώτηση αφορούσε μόνο το κομμάτι που σχετίζεται με την εξαγωγή αρχείων από .jar αρχείο. Μάθαμε πολλά για τις κλάσεις JarFile και JarEntry που χρησιμοποιούνται ειδικά για αυτό το σκοπό, αλλά και για την URI, μέσω της οποίας μπορείς να αναφερθείς σε αρχείο μέσα σε .jar σα να είναι κανονικό μονοπάτι. Τα paths έχουν παρόμοιο scheme με τα URL και αυτό είναι κάτι εξαιρετικά χρήσιμο που εμπεδώσαμε χάρη στη σωστή χρήση ΠΤΝ.

#### Β. Η ανάγκη ελέγχου συμπεριφοράς components από components άλλων panel

Επειδή τα διάφορα components (buttons, spinners, labels) είναι τοποθετημένα σε διαφορετικά panels, ακόμα δε και σε διαφορετικά frames, στην αρχή δεν υπήρχε πρόσβαση από ένα component (πχ combobox που υλοποιεί την επιλογή έτους) σε ένα (ή περισσότερα) άλλου panel. Αυτό λύθηκε με το πέρασμα παραμέτρων, ξεκινώντας από τις κλάσεις που υλοποιούν τα δύο βασικά παράθυρα, “Budget_origin_window_model.java” και “Budget_distribution_window_model.java”. Τα ονόματα φανερώνουν τί στιγμιότυπα δημιουργούν.

Κάθε μία από αυτές τις κλάσεις, έκτισε μία ArrayList από panel και πέρασε σε αυτήν όσα panel τοποθετήθηκαν στο frame της. Η λίστα με τα panel πέρασε ως παράμετρος στην κλάση (πιο σωστά, τα στιγμιότυπά της που δημιουργήθηκαν) που τοποθετεί αυτόματα μέσω πίνακα τα components στο panel, την “ Panel_using_array.java” που κληρονομεί την Jpanel και άρα αποτελεί είδος panel.

Η κλάση αυτή με τη σειρά της περνάει σε κάθε (ειδικά σχεδιασμένο) component που τοποθετεί στο panel τη λίστα με τα panel στα οποία θα έχουν έλεγχο μέσω getter/setter για τα components αυτών. Τα ειδικά αυτά components είναι: 
•	Listening_button, που κληρονομεί την JBbutton
•	Listening_spinner, που κληρονομεί την JSpinner
Και δέχονται παραμέτρους για επιλογή συμπεριφοράς ανάλογα το panel που βρίσκονται και ελέγχουν.
Υπάρχει και η κλάση Listening_combobox, που κληρονομεί την JComboBox, αλλά αυτή τοποθετήθηκε σε panel που σχηματίστηκε χειροκίνητα, με μοναδικό σκοπό να ελέγχει διαδικασίες που αφορούν τα έτη.


### Πηγές έμπνευσης:

```
•	«Πλήρες εγχειρίδιο της JAVA 12», Rogers Cadenhead, Εκδόσεις Μ. Γκιούρδας, Μάθημα 9, «Δημιουργία ενός Γραφικού Περιβάλλοντος Χρήστη»
•	https://www.geeksforgeeks.org/
•	https://www.w3schools.com/java/
•	https://stackoverflow.com/
•	https://docs.oracle.com/javase/tutorial/
•	ChatGPT ως Παραγωγική Τεχνητή Νοημοσύνη
```
